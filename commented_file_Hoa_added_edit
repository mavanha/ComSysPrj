#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>
#include <stdlib.h> // Included for abs() used in signal processing

// --- Pico SDK Headers ---
// These provide access to the specific hardware of the Raspberry Pi Pico
#include "pico/bootrom.h"
#include "pico/stdlib.h"
#include "pico/stdio.h"
#include "pico/cyw43_arch.h" // Required for Wi-Fi chip control on Pico W

// --- FreeRTOS Headers ---
// We use a Real-Time Operating System to handle multiple tasks (Input, Output, Display) simultaneously
#include <FreeRTOS.h>
#include <queue.h>
#include <task.h>
#include <semphr.h>

// --- Hardware Abstraction Layer ---
// Custom TKJHAT SDK: IMU, microphone, buzzer, RGB LED, buttons, OLED, etc.
// The general structure follows the examples from the Intro to Computer Systems
// course materials and the TKJHAT SDK documentation, adapted to our project.
#include "tkjhat/sdk.h" // Custom library for the specific HAT hardware (IMU, Display, Buttons)

/* ==========================================
 * CONFIGURATION & MACROS
 * ========================================== */

// Button Configuration
#define BTN_MODE            BUTTON1 // SW1: Used to switch input modes (IMU <-> Mic) or send Message
#define BTN_ACTION          BUTTON2 // SW2: Used to input a Dot/Dash or a Space
#define BTN_LONG_PRESS_MS   800     // How long (ms) to hold a button to trigger a "Long Press"
#define BTN_DEBOUNCE_MS     150     // Time to ignore button noise after a press

// Microphone Tuning
#define MIC_AMPL_THRESHOLD  8000    // Audio volume threshold. Below this is silence, above is signal.
#define MIC_DOT_MAX_MS      250     // If sound is shorter than this = Dot (.). Longer = Dash (-).

// Task Timing
#define INPUT_TASK_PERIOD_MS 20     // How often the input task runs (50Hz). Good balance of responsiveness vs CPU usage.

// Queue Sizes
#define SYMBOL_QUEUE_LENGTH     64   // Holds raw symbols: '.', '-', ' '
#define EVENT_QUEUE_LENGTH      8    // Holds system events like "Message Sent"

// --- Enums for State Machines ---
// Tracks which input method we are currently using
typedef enum {
    INPUT_MODE_IMU = 0, // Tilting the board
    INPUT_MODE_MIC = 1  // Making noise
} input_mode_t;

// Tracks the internal state of the microphone logic
typedef enum {
    MIC_STATE_IDLE = 0, // Waiting for sound
    MIC_STATE_ACTIVE    // Currently recording a sound
} mic_state_t;

// Events meant for the Buzzer/System task (Jonathan – feedback logic)
typedef enum {
    APP_EVENT_MSG_SENT = 0
} app_event_t;

/* ==========================================
 * GLOBAL VARIABLES
 * ========================================== */

// Current input mode (shared across tasks)
static input_mode_t g_inputMode = INPUT_MODE_IMU; 

// ---- Microphone state ----
static volatile int g_mic_samples_ready = 0;     // Flag set by interrupt when mic data is available
static int16_t      g_mic_buffer[MEMS_BUFFER_SIZE]; // Buffer to store raw audio data from MEMS microphone

// --- FreeRTOS Handles ---
// Queue that carries individual Morse symbols from input_task to serial_tx_task
static QueueHandle_t xSymbolQueue = NULL;
// Queue that delivers high-level application events (e.g. "message sent") to vBuzzerTask
static QueueHandle_t xEventQueue  = NULL; 

// Priorities: IDLE + 2 ensures these tasks run over background cleanup jobs
#define MAIN_TASK_PRIORITY (tskIDLE_PRIORITY + 2)

// Queue settings for RX/TX and playback logic
#define SERIAL_TX_QUEUE_LENGTH 20 
#define PLAYBACK_QUEUE_LENGTH  40
#define SERIAL_RX_BUFFER_SIZE  128

// --- IMU Thresholds ---
// We define "Tilt" logic. 1.0f is full gravity (90 degrees). 
// 0.9f requires a significant tilt to prevent accidental inputs.
#define IMU_TILT_THRESHOLD      0.9f
#define IMU_NEUTRAL_THRESHOLD   0.5f
#define IMU_JERK_THRESHOLD      0.4f
#define IMU_DEBOUNCE_MS         300

// IMU State Machine for tilt-based input (Hoà – Sensors & Input part)
volatile enum AppState {
  STATE_IDLE,     // Waiting for user input
  STATE_ARMED,    // Ready to read tilt
  STATE_COOLDOWN  // Waiting for sensor to return to flat position
} g_appState = STATE_IDLE;

// --- FreeRTOS Queue Handles ---
QueueHandle_t xSerialTxQueue_actual; // Sends data to USB UART (not used heavily here, kept for compatibility)
QueueHandle_t xPlaybackQueue;        // Sends data to OLED and LED/Buzzer (for RX and TX feedback)
QueueHandle_t i2cMutex;              // PROTECTS HARDWARE: Prevents IMU and OLED from using the I2C bus at the same time

// Morse Code Lookup Table (used for translating dots/dashes to characters)
struct MorseAlphabet {
  char morseCode[7]; // e.g., ".-"
  char letter;       // e.g., 'A'
};

struct MorseAlphabet morseCodes[40] = {
  {".-", 'a'}, {"-...", 'b'}, {"-.-.", 'c'}, {"-..", 'd'}, {".", 'e'},
  {"..-.", 'f'}, {"--.", 'g'}, {"....", 'h'}, {"..", 'i'}, {".---", 'j'},
  {"-.-", 'k'}, {".-..", 'l'}, {"--", 'm'}, {"-.", 'n'}, {"---", 'o'},
  {".--.", 'p'}, {"--.-", 'q'}, {".-.", 'r'}, {"...", 's'}, {"-", 't'},
  {"..-", 'u'}, {"...-", 'v'}, {"", 'w'}, {"-..-", 'x'}, {"-.--", 'y'},
  {"--..", 'z'}, {"-----", '0'}, {".----", '1'}, {"..---", '2'},
  {"...--", '3'}, {"....-", '4'}, {".....", '5'}, {"-....", '6'},
  {"--...", '7'}, {"---..", '8'}, {"----.", '9'}, {".-.-.-", '.'},
  {"--..--", ','}, {"..--..", '?'}, {"-.-.--", '!'}, {"", ' '}
/* NOTE: The Morse table data itself is based on the standard
 * International Morse code, not copied from a specific source,
 * but the idea of storing codes in a struct array is common in
 * many Morse examples online.
 */
};

/* ==========================================
 * FUNCTION PROTOTYPES
 * ========================================== */
static void input_task(void *pvParameters);
static void serial_tx_task(void *pvParameters);
static void serial_rx_task(void *pvParameters);
static void playback_task(void *pvParameters);
static void vBuzzerTask(void *pvParameters);

char find_letter_from_morse_code(char *morseCode);
void process_received_line(char *line);

// Helper to push a character into the internal queue safely
static void send_symbol(char c) {
    xQueueSend(xSymbolQueue, &c, 0); 
}

static void send_space(void) {
    char space = ' ';
    send_symbol(space);
}

/* ==========================================
 * MICROPHONE CALLBACK (Hoà – Sensors & Input)
 * ========================================== */
/*
 * This callback is registered in the TKJHAT SDK microphone driver. Whenever a
 * new block of PDM microphone samples is available, the driver calls this
 * function from an interrupt context. We just copy the samples into a global
 * buffer and set a flag so that the input_task can process the audio data
 * later in a normal task context.
 *
 * The overall pattern (ISR sets a flag, task reads the data) follows the
 * approach used in the course example code for the MEMS microphone.
 */
static void on_pdm_samples_ready(void) {
    int n = get_microphone_samples(g_mic_buffer, MEMS_BUFFER_SIZE);
    if (n > 0) {
        g_mic_samples_ready = n; // Signal the main loop that data is ready to process
    }
}

/* ==========================================
 * MAIN FUNCTION
 * ========================================== */
int main() {
    // 1. Initialize Standard I/O (USB Serial)
    stdio_init_all();

    // Wait for USB connection so we don't miss initial print statements.
    // Pattern similar to the Pico SDK stdio_usb example: we poll until
    // the host opens the USB serial port or a timeout elapses.
    int i = 0;
    while (!stdio_usb_connected() && i < 30) { 
        sleep_ms(100);
        i++;
    }
    
    printf("__JTKJ Morse Communicator - Starting...__\n");

    // 2. Initialize Wi-Fi (CYW43)
    // Even if we don't use internet features, initializing this is often required
    // for the board's LED or power management on the Pico W.
    printf("Init the cyw43\n");
    if (cyw43_arch_init()) {
        printf("WiFi init failed! (Continuing without Wi-Fi)\n");
    } else {
        printf("Connecting to Wi-Fi\n");
        cyw43_arch_enable_sta_mode();
        
        // Attempt connection to open network 'panoulu'
        // This pattern is based on cyw43_arch_wifi_connect_timeout_ms()
        // from the official Raspberry Pi Pico W examples.
        if(cyw43_arch_wifi_connect_timeout_ms("panoulu", NULL, CYW43_AUTH_OPEN, 30 * 1000)) {
            printf("Failed to connect to Wi-Fi (Running Offline)\n");
        } else {
            printf("Connected to hotspot\n");
        }
    }

    // 3. Initialize HAT Hardware
    init_hat_sdk(); 
    init_led();   
    init_rgb_led();
    init_buzzer();
    init_display();

    // Initialize IMU (Accelerometer/Gyro)
    if (init_ICM42670() == 0) {
        printf("__IMU INIT OK__\n");
        ICM42670_start_with_default_values();
    } else {
        printf("__IMU INIT FAILED__\n");
    }

    // Initialize Microphone
    if (init_pdm_microphone() == 0) {
        pdm_microphone_set_callback(on_pdm_samples_ready);
        init_microphone_sampling();
        printf("__MIC INIT OK__\n");
    } else {
        printf("__MIC INIT FAILED__\n");
    }

    // Initial Display Setup
    clear_display();
    write_text_xy(0, 0, "Morse App Ready");
    write_text_xy(0, 10, "SW1=Mode, SW2=Action"); 
    write_text_xy(0, 30, "RX MSG:");

    // 4. Create FreeRTOS Queues
    xSerialTxQueue_actual = xQueueCreate(SERIAL_TX_QUEUE_LENGTH, sizeof(char)); 
    xPlaybackQueue        = xQueueCreate(PLAYBACK_QUEUE_LENGTH, sizeof(char));
    xSymbolQueue          = xQueueCreate(SYMBOL_QUEUE_LENGTH, sizeof(char)); 
    xEventQueue           = xQueueCreate(EVENT_QUEUE_LENGTH, sizeof(app_event_t)); 
    
    // Create Mutex: A "Lock" for the I2C bus (Display and IMU are on same bus)
    i2cMutex = xSemaphoreCreateMutex();
    
    // Error check
    if (xSerialTxQueue_actual == NULL || xPlaybackQueue == NULL || 
        i2cMutex == NULL || xSymbolQueue == NULL || xEventQueue == NULL) {
        printf("__CRITICAL ERROR: Could not create queues or mutex__\n");
        while (1) { blink_led(1); sleep_ms(100); }
    }

    // 5. Create Tasks
    // Separate tasks for: input logic, serial TX/RX, playback, buzzer feedback.
    xTaskCreate(input_task,   "InputTask",    2048, NULL, MAIN_TASK_PRIORITY, NULL);
    xTaskCreate(serial_tx_task, "TxTask",     2048, NULL, MAIN_TASK_PRIORITY, NULL);
    xTaskCreate(serial_rx_task, "RxTask",     2048, NULL, MAIN_TASK_PRIORITY, NULL);
    xTaskCreate(playback_task,  "PlaybackTask", 4096, NULL, MAIN_TASK_PRIORITY, NULL);
    xTaskCreate(vBuzzerTask,    "BuzzerTask",   1024, NULL, MAIN_TASK_PRIORITY, NULL);

    printf("__Initialization complete. Starting scheduler.__\n");

    // 6. Start the OS
    vTaskStartScheduler();

    // Code should never reach here unless OS fails
    while (1); 
    return 0;
}

/* ==========================================
 * TASK: INPUT HANDLING (Buttons, IMU, Mic)
 * Hoà – Sensors & Input + FSM
 * ========================================== */
/*
 * This FreeRTOS task is responsible for capturing all user input and converting
 * it into Morse symbols ('.', '-', and spaces). It merges three sources:
 *
 *  1) IMU (ICM42670) orientation: used to generate DOT/DASH when the user tilts
 *     the board and presses SW2 in IMU mode.
 *  2) MEMS Microphone: used to generate DOT/DASH based on the duration and
 *     amplitude of sound events in MIC mode.
 *  3) Buttons:
 *       - SW1 (BTN_MODE): short press toggles between IMU and MIC modes;
 *                         long press sends three spaces to mark end-of-message.
 *       - SW2 (BTN_ACTION): short/long press interpreted as symbol or space
 *                           depending on the current mode.
 *
 * The debouncing and long-press logic is inspired by typical embedded button
 * handling patterns seen in microcontroller examples, but the exact timing and
 * state machine design were implemented by our group for this project.
 */
static void input_task(void *pvParameters) {
    (void)pvParameters;

    // IMU variables
    float ax, ay, az, gx, gy, gz, t;
    float prev_ax = 0, prev_ay = 0, prev_az = 0;
    bool read_ok_imu = false; 

    // Button Logic Variables
    bool       sw1_prev = false;
    bool       sw2_prev = false;
    TickType_t sw1_press_tick = 0;  // When was SW1 pressed?
    TickType_t sw2_press_tick = 0;  // When was SW2 pressed?
    TickType_t sw1_last_change = 0; // For debouncing
    TickType_t sw2_last_change = 0; // For debouncing

    // Mic Logic Variables
    mic_state_t micState = MIC_STATE_IDLE;
    TickType_t  micStartTick = 0;

    // Initialize SW1/SW2 using TKJHAT SDK helper functions
    init_sw1(); 
    init_sw2();

    g_inputMode = INPUT_MODE_IMU; // Default to IMU mode
    printf("__IMU MODE__\n");

    while (1) {
        TickType_t now = xTaskGetTickCount();

        // Read raw button states
        bool sw1_now = gpio_get(BTN_MODE)   ? true : false;
        bool sw2_now = gpio_get(BTN_ACTION) ? true : false;

        // -------- BUTTON SW1 LOGIC (Mode Switch / End Message) --------
        // Debounce: only react if state changed AND minimum time elapsed.
        if (sw1_now != sw1_prev && (now - sw1_last_change) > pdMS_TO_TICKS(BTN_DEBOUNCE_MS)) {
            sw1_last_change = now;
            
            if (sw1_now) { // Button Just Pressed
                buzzer_play_tone(1000, 80); 
                sw1_press_tick = now; // Mark start time
            } else { // Button Just Released
                TickType_t dt = now - sw1_press_tick;
                uint32_t ms   = dt * portTICK_PERIOD_MS;
                
                if (ms >= BTN_LONG_PRESS_MS) {
                    // Long press: "send message" by queuing three spaces.
                    // This matches the Morse protocol where 3 spaces mark end-of-message.
                    printf("__MSG SEND VIA 3 SPACES__\n");
                    send_space(); send_space(); send_space();
                    
                    // Also trigger feedback event (Jonathan – feedback requirement)
                    app_event_t evt = APP_EVENT_MSG_SENT;
                    xQueueSend(xEventQueue, &evt, 0); 
                } else {
                    // Short press: toggle between IMU mode and MIC mode
                    if (g_inputMode == INPUT_MODE_IMU) {
                        g_inputMode = INPUT_MODE_MIC;
                        micState = MIC_STATE_IDLE; 
                        printf("__MIC MODE__\n");
                    } else {
                        g_inputMode = INPUT_MODE_IMU;
                        g_appState = STATE_IDLE; 
                        set_led_status(false); 
                        printf("__IMU MODE__\n");
                    }
                }
            }
        }
        sw1_prev = sw1_now;

        // -------- BUTTON SW2 LOGIC (Symbol / Space) --------
        if (sw2_now != sw2_prev && (now - sw2_last_change) > pdMS_TO_TICKS(BTN_DEBOUNCE_MS)) {
            sw2_last_change = now;
            
            if (sw2_now) { 
                buzzer_play_tone(700, 80); 
                sw2_press_tick = now;
            } else { 
                TickType_t dt = now - sw2_press_tick;
                uint32_t ms   = dt * portTICK_PERIOD_MS;
                
                if (ms >= BTN_LONG_PRESS_MS) {
                    // Long press on SW2 generates a space (word break).
                    send_space();
                    printf("__SPACE__\n");
                } else {
                    // Short press: behaviour depends on IMU or MIC mode.
                    if (g_inputMode == INPUT_MODE_IMU) {
                        // IMU Logic: use current orientation to determine DOT or DASH.
                        if (g_appState == STATE_IDLE) {
                            g_appState = STATE_ARMED; // Arm the sensor
                            set_led_status(true);
                            printf("__IMU ARMED__\n");
                        } else if (g_appState == STATE_ARMED) {
                            // Read IMU Data protected by Mutex (shares I2C with OLED)
                            read_ok_imu = false;
                            if (xSemaphoreTake(i2cMutex, pdMS_TO_TICKS(50)) == pdTRUE) {
                                if (ICM42670_read_sensor_data(&ax, &ay, &az, &gx, &gy, &gz, &t) == 0) {
                                    read_ok_imu = true;
                                }
                                xSemaphoreGive(i2cMutex); // Always give back mutex!
                            }

                            if (read_ok_imu) {
                                char symbol = '?';
                                // Check orientation:
                                if (az > IMU_TILT_THRESHOLD)        symbol = '.'; // Board Tilted Forward
                                else if (ay < -IMU_TILT_THRESHOLD)  symbol = '-'; // Board Tilted Left

                                if (symbol != '?') {
                                    send_symbol(symbol);
                                    printf("__IMU SYMBOL '%c'__\n", symbol);
                                    set_led_status(false);
                                    g_appState = STATE_COOLDOWN; 
                                }
                            }
                        }
                    } else {
                        // In MIC mode, SW2 short press does not generate a symbol directly.
                        printf("__SW2 SHORT IN MIC MODE - no direct action__\n");
                    }
                }
            }
        }
        sw2_prev = sw2_now;

        // -------- IMU STATE MACHINE (Cooldown) --------
        // Ensures user returns board to approx. neutral (flat) position before next IMU input.
        if (g_inputMode == INPUT_MODE_IMU && g_appState == STATE_COOLDOWN) {
             read_ok_imu = false;
             if (xSemaphoreTake(i2cMutex, pdMS_TO_TICKS(50)) == pdTRUE) {
                if (ICM42670_read_sensor_data(&ax, &ay, &az, &gx, &gy, &gz, &t) == 0) {
                     read_ok_imu = true;
                }
                xSemaphoreGive(i2cMutex);
             }

             if (read_ok_imu) {
                 // Check if board is roughly flat (neutral)
                 if (fabs(az) < IMU_NEUTRAL_THRESHOLD && fabs(ay) < IMU_NEUTRAL_THRESHOLD) {
                     g_appState = STATE_IDLE; 
                     printf("__IMU COOLED DOWN (IDLE)__\n");
                 }
             }
        }

        // -------- MICROPHONE PROCESSING (MIC MODE) --------
        if (g_inputMode == INPUT_MODE_MIC && g_mic_samples_ready > 0) {
            int sample_count = g_mic_samples_ready;
            g_mic_samples_ready = 0; // Clear flag

            // Calculate Volume (Average Absolute Amplitude)
            int64_t sumAbs = 0;
            for (int loop_i = 0; loop_i < sample_count; loop_i++) {
                sumAbs += abs(g_mic_buffer[loop_i]);
            }
            uint32_t avgAbs = (uint32_t)(sumAbs / sample_count);

            // Simple 2-state mic state machine for DOT/DASH detection.
            switch (micState) {
                case MIC_STATE_IDLE:
                    if (avgAbs > MIC_AMPL_THRESHOLD) {
                        micState = MIC_STATE_ACTIVE; // Sound started
                        micStartTick = now;
                        printf("__MIC ACTIVE__\n");
                    }
                    break;
                case MIC_STATE_ACTIVE:
                    if (avgAbs <= MIC_AMPL_THRESHOLD) { // Sound stopped
                        // Calculate duration to decide Dot vs Dash
                        TickType_t durationTicks = now - micStartTick;
                        uint32_t durationMs = durationTicks * portTICK_PERIOD_MS;
                        char symbol = (durationMs <= MIC_DOT_MAX_MS) ? '.' : '-';
                        
                        printf("__MIC INPUT: %c (%lu ms)__\n", symbol, (unsigned long)durationMs);
                        send_symbol(symbol);
                        micState = MIC_STATE_IDLE;
                    }
                    break;
                default: 
                    micState = MIC_STATE_IDLE; 
                    break;
            }
        }

        // Yield CPU to other tasks.
        vTaskDelay(pdMS_TO_TICKS(INPUT_TASK_PERIOD_MS));
    }
}

/* ==========================================
 * TASK: SERIAL TRANSMISSION (Device -> PC)
 * ========================================== */
/*
 * This task reads Morse symbols from xSymbolQueue and sends them to the
 * workstation via USB serial. It also mirrors those symbols into the
 * playback queue so that the OLED and actuators can reflect what is
 * being transmitted.
 *
 * When three consecutive spaces are seen, the task considers the message
 * complete and:
 *   - Sends a newline over serial (end of line for the serial client).
 *   - Pushes '\n' to the playback queue to tell the display task to update.
 *   - Sends APP_EVENT_MSG_SENT to the buzzer task to play a confirmation
 *     melody (Jonathan – feedback requirement).
 */
static void serial_tx_task(void *pvParameters) {
    (void)pvParameters;
    char symbol;
    int spaceCount = 0;

    while (1) {
        // Block indefinitely until a symbol arrives in the queue
        if (xQueueReceive(xSymbolQueue, &symbol, portMAX_DELAY) == pdPASS) { 
            if (symbol == ' ') {
                spaceCount++;
                putchar(' '); 
                fflush(stdout);

                // Logic: 3 consecutive spaces mean "End of Message"
                if (spaceCount == 3) {
                    putchar('\n'); // Send newline to serial
                    printf("\n__[Morse Send OK]__\n");
                    fflush(stdout);
                    
                    spaceCount = 0;
                    
                    // Tell the Playback/Display task that the message is done
                    char nl_char = '\n';
                    xQueueSend(xPlaybackQueue, &nl_char, 0); 
                    
                    // Tell the Buzzer task to play success sound (Jonathan)
                    app_event_t evt = APP_EVENT_MSG_SENT;
                    xQueueSend(xEventQueue, &evt, 0); 
                }
            } else {
                // If it's a dot or dash, reset space counter
                spaceCount = 0;
                putchar(symbol); 
                fflush(stdout);
                // Echo input to local display immediately
                xQueueSend(xPlaybackQueue, &symbol, 0);
            }
        }
    }
}

/* ==========================================
 * TASK: SERIAL RECEIVING (PC -> Device)
 * Hoà – Tier 2: workstation -> device
 * ========================================== */
/*
 * This task continuously polls the USB serial interface for incoming data.
 * It assembles bytes into lines terminated by '\n' or '\r'. Each completed
 * line is passed to process_received_line(), which parses Morse data or
 * simple commands (.clear, .boot).
 *
 * The general pattern (getchar_timeout_us loop + line buffer) is similar to
 * examples in the Pico SDK documentation, but extended with Morse parsing
 * and the debug block handling defined by the course serial client.
 */
static void serial_rx_task(void *pvParameters) {
    (void)pvParameters;

    char lineBuffer[SERIAL_RX_BUFFER_SIZE];
    int  linePos = 0;

    while (1) {
        int c = getchar_timeout_us(0);
        
        if (c != PICO_ERROR_TIMEOUT) {
            // If End of Line detected, process the full string
            if (c == '\n' || c == '\r') {
                if (linePos > 0) {
                    lineBuffer[linePos] = '\0';
                    process_received_line(lineBuffer);
                    linePos = 0;
                }
            } else if (linePos < (SERIAL_RX_BUFFER_SIZE - 1)) {
                lineBuffer[linePos++] = (char)c;
            } else {
                linePos = 0; // Buffer overflow protection: reset
            }
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

// Parses commands (.clear, .boot) and incoming Morse strings from workstation
/*
 * This function takes a complete line from the serial_rx_task and:
 *  - Executes local commands such as ".clear" (clear terminal) or ".boot"
 *    (enter USB bootloader). These commands follow the instructions of the
 *    provided serial client program in the course.
 *  - Parses Morse code characters from the line, ignoring any debug blocks
 *    wrapped in "__...__". Valid Morse characters ('.', '-', ' ') are
 *    forwarded to xPlaybackQueue, and finally a '\n' is sent to signal the
 *    end of the received Morse message.
 */
void process_received_line(char *line) {
    // Check for commands
    if (strncmp(line, ".clear", 6) == 0) {
        // ANSI escape sequence to clear the terminal; this pattern is common
        // in many serial terminal examples, not taken from a specific site.
        printf("\033[2J\033[H"); // Clear screen + move cursor home
        fflush(stdout);
        return;
    }
    if (strncmp(line, ".boot", 5) == 0) {
        reset_usb_boot(0, 0); // Special Pico command to enter bootloader (from Pico SDK docs)
        return;
    }

    // Parse Morse characters (ignoring debug tags like __DEBUG__)
    bool in_debug_block = false;
    for (int i = 0; line[i] != '\0'; i++) { 
        if (line[i] == '_' && line[i+1] == '_') {
            in_debug_block = !in_debug_block; // Toggle debug mode
            i++; 
            continue;
        }
        if (!in_debug_block) {
            char symbol = line[i];
            // Forward valid Morse symbols to the playback task
            if (symbol == '.' || symbol == '-' || symbol == ' ') {
                xQueueSend(xPlaybackQueue, &symbol, portMAX_DELAY);
            }
        }
    }
    // Trigger display update (end-of-message)
    char nl = '\n';
    xQueueSend(xPlaybackQueue, &nl, portMAX_DELAY);
}

/* ==========================================
 * TASK: PLAYBACK & DISPLAY
 * Hoà – Tier 2: LCD + LED/Buzzer representation
 * ========================================== */
/*
 * This task consumes symbols from xPlaybackQueue (both locally generated
 * and received from the workstation) and:
 *
 *  1) Provides physical feedback:
 *       - RGB LED colors for DOT, DASH, SPACE.
 *       - Buzzer tones for DOT and DASH.
 *  2) Translates sequences of dots/dashes into characters using the
 *     morseCodes lookup table.
 *  3) Updates the SSD1306 OLED display with the translated text.
 *
 * The idea of using queues to decouple reception and display is inspired
 * by typical FreeRTOS designs (producer/consumer pattern), but the actual
 * mapping of symbols, colors, and tones was designed by our group.
 */
static void playback_task(void *pvParameters) {
    (void)pvParameters;
    char symbol;
    char morseSymbolBuffer[10] = {0}; // Holds current letter (e.g., "...")
    int morseSymbolPos = 0;
    char textMessageBuffer[22] = {0}; // Holds translated text
    int textMessagePos = 0;

    while (1) {
        // Wait for data from Input or RX tasks
        if (xQueueReceive(xPlaybackQueue, &symbol, portMAX_DELAY) == pdPASS) {
            
            // --- 1. Physical Feedback (LEDs/Buzzer) ---
            if (symbol == '.') {
                rgb_led_write(255, 255, 0); // Yellow for DOT
                buzzer_play_tone(880, 150);
                vTaskDelay(pdMS_TO_TICKS(150));
                if (morseSymbolPos < 9) morseSymbolBuffer[morseSymbolPos++] = '.';
            }
            else if (symbol == '-') {
                rgb_led_write(255, 0, 255); // Magenta for DASH
                buzzer_play_tone(660, 400);
                vTaskDelay(pdMS_TO_TICKS(400));
                if (morseSymbolPos < 9) morseSymbolBuffer[morseSymbolPos++] = '-';
            }
            // --- 2. Translation Logic (Space or Newline) ---
            else if (symbol == ' ') {
                rgb_led_write(0, 255, 255); // Cyan for letter separator
                vTaskDelay(pdMS_TO_TICKS(200));
                
                // Translate accumulated Morse ("...") to Char ('S')
                morseSymbolBuffer[morseSymbolPos] = '\0';
                char letter = find_letter_from_morse_code(morseSymbolBuffer);
                if (textMessagePos < 20) textMessageBuffer[textMessagePos++] = letter;
                
                // Reset symbol buffer
                morseSymbolPos = 0;
                memset(morseSymbolBuffer, 0, sizeof(morseSymbolBuffer));
            }
            else if (symbol == '\n') {
                // End of message: Translate any remaining symbols
                morseSymbolBuffer[morseSymbolPos] = '\0';
                if (morseSymbolPos > 0) {
                    char letter = find_letter_from_morse_code(morseSymbolBuffer);
                    if (textMessagePos < 20) textMessageBuffer[textMessagePos++] = letter;
                }
                textMessageBuffer[textMessagePos] = '\0'; 
               
                // --- 3. Update OLED Display ---
                // Critical: Take the I2C mutex because OLED and IMU share the same bus.
                if (xSemaphoreTake(i2cMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
                    clear_display();
                    // Draw UI
                    write_text_xy(0, 0, "Morse App Ready");
                    write_text_xy(0, 10, "SW1=Mode, SW2=Action");
                    write_text_xy(0, 30, "RX MSG:");
                    // Draw Translated Text
                    if (textMessagePos > 0) {
                        write_text_xy(0, 40, textMessageBuffer);
                    }
                    xSemaphoreGive(i2cMutex); // Release Mutex immediately
                }

                // Reset text buffer for next message
                textMessagePos = 0;
                morseSymbolPos = 0;
                memset(textMessageBuffer, 0, sizeof(textMessageBuffer));
                memset(morseSymbolBuffer, 0, sizeof(morseSymbolBuffer));
            }
            
            // Reset LED to white / neutral between symbols
            rgb_led_write(255, 255, 255);
            vTaskDelay(pdMS_TO_TICKS(100));
        }
    }
}

/* ==========================================
 * TASK: BUZZER EVENTS (Jonathan – feedback)
 * ========================================== */

// Simple non-blocking melody played when a message is sent successfully.
// Uses the new non-blocking buzzer_start_tone / buzzer_stop_tone API discussed
// in our library-efficiency improvements.
static void play_message_sent_melody(void)
{ 
    init_buzzer(); // Still called to ensure buzzer GPIO/PWM is initialized

    // Note 1 
    buzzer_start_tone(880); 
    vTaskDelay(pdMS_TO_TICKS(120)); 
    buzzer_stop_tone(); 
    vTaskDelay(pdMS_TO_TICKS(20)); 

    // Note 2 
    buzzer_start_tone(988); 
    vTaskDelay(pdMS_TO_TICKS(120)); 
    buzzer_stop_tone(); 
    vTaskDelay(pdMS_TO_TICKS(20)); 

    // Note 3 
    buzzer_start_tone(1047); 
    vTaskDelay(pdMS_TO_TICKS(200)); 
    buzzer_stop_tone();
}

// Buzzer task: waits for APP_EVENT_MSG_SENT and plays the confirmation melody.
static void vBuzzerTask(void *pvParameters) {
     (void)pvParameters;
     app_event_t evt;
     while (1) {
         // Wait for system events (like Message Sent)
         if (xQueueReceive(xEventQueue, &evt, portMAX_DELAY) == pdTRUE) {
             if (evt == APP_EVENT_MSG_SENT) {
                 play_message_sent_melody();
             }
         }
     }
}

// Helper: Translates ".-" to 'A'
/*
 * Lookup helper for converting a Morse string (e.g. ".-") into a character
 * using the morseCodes table above. Returns a space if the Morse string is
 * empty, '?' if the pattern is unknown.
 */
char find_letter_from_morse_code(char *morseCode) {
    if (strlen(morseCode) == 0) return ' '; 
    for (int i = 0; i < 40; i++){ 
        if (strcmp(morseCode, morseCodes[i].morseCode) == 0){
            return (char)toupper(morseCodes[i].letter);
        }
    }
    return '?'; // Unknown pattern
}
